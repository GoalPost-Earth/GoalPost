# GoalPost GraphQL Schema - Neo4j GraphQL
# Designed for pulse-first, context-aware relational data modeling.
#
# Architecture:
# - Pulses are the write path (first-class citizens)
# - Resonance is the read/insight path (AI-generated meaning)
# - Spaces define privacy boundaries (MeSpace/WeSpace)
# - AI adds meaning after the fact (explainability layer)

extend schema @authentication

# ============================================================================
# CORE ACTORS (Who initiates pulses & owns spaces)
# ============================================================================

"""
A human user of the system.
Multi-label: ["Person", "User"]
Authorization: Can only view people who are owners or members of shared spaces.
"""
type Person
  @node(labels: ["Person"])
  @authorization(
    filter: [
      {
        where: {
          node: {
            OR: [
              # Person owns a space where current user is owner
              { ownsSpaces_SOME: { owner_SOME: { id_EQ: "$jwt.user.id" } } }
              # Person owns a space where current user is member
              {
                ownsSpaces_SOME: {
                  members_SOME: { member_SOME: { id_EQ: "$jwt.user.id" } }
                }
              }
              # Person is a member of a space where current user is also a member
              {
                memberOf_SOME: {
                  space_SOME: {
                    members_SOME: { member_SOME: { id_EQ: "$jwt.user.id" } }
                  }
                }
              }
              # Current user is the person themselves
              { id_EQ: "$jwt.user.id" }
            ]
          }
        }
      }
    ]
  ) {
  id: ID! @id
  firstName: String!
  lastName: String!
  name: String! @customResolver(requires: "firstName lastName")
  email: String
  ownsSpaces: [Space!]! @relationship(type: "OWNS", direction: OUT)
  memberOf: [SpaceMembership!]! @relationship(type: "IS_MEMBER", direction: OUT)
}

"""
User authentication and preferences.
Extends Person with login and feature flags.
Multi-label: ["Person", "User"]
"""
type User @node(labels: ["Person", "User"]) {
  id: ID! @id
  firstName: String!
  lastName: String!
  name: String! @customResolver(requires: "firstName lastName")
  email: String
  aiEnabled: Boolean!
  ownsSpaces: [Space!]! @relationship(type: "OWNS", direction: OUT)
}

"""
A collective identity (team, family, cohort, etc).
Has members and can own spaces and initiate pulses.
Multi-label: ["Community"]
"""
type Community @node(labels: ["Community"]) {
  id: ID! @id
  name: String!
  type: String
  members: [LifeSensor!]! @relationship(type: "HAS_MEMBER", direction: OUT)
  ownsSpaces: [Space!]! @relationship(type: "OWNS", direction: OUT)
}

"""
Anything that can initiate pulses or own spaces.
Query-time abstraction - either a Person or Community.
"""
union LifeSensor = Person | Community

# ============================================================================
# SPACES (Privacy + Ownership Boundary)
# ============================================================================

"""
Role-based permission for space membership.
ADMIN: Can manage members and modify pulses/contexts
MEMBER: Can create and modify pulses/contexts
GUEST: Can view pulses and contexts (read-only)
"""
enum SpaceRole {
  ADMIN
  MEMBER
  GUEST
}

"""
Abstract space type.
Never instantiated directly - use MeSpace or WeSpace.
"""
interface Space {
  id: ID!
  name: String!
  visibility: SpaceVisibility!
  createdAt: DateTime!
  owner: [Person!]! @declareRelationship
  members: [SpaceMembership!]! @declareRelationship
  contexts: [FieldContext!]! @declareRelationship
}

enum SpaceVisibility {
  PRIVATE
  SHARED
}

"""
A personal space owned by one person or community.
Can be private (only owner) or shared with specific members.
Multi-label: ["Space", "MeSpace"]
Authorization: Only the owner can view, create, update, or delete a MeSpace.
"""
type MeSpace implements Space @node(labels: ["Space", "MeSpace"]) {
  id: ID! @id
  name: String!
  visibility: SpaceVisibility!
  createdAt: DateTime!
  owner: [Person!]! @relationship(type: "OWNS", direction: IN)
  members: [SpaceMembership!]! @relationship(type: "HAS_MEMBER", direction: OUT)
  contexts: [FieldContext!]! @relationship(type: "HAS_CONTEXT", direction: OUT)
}

"""
A collaborative space shared with other people.
Has an owner and members who can all participate.
Multi-label: ["Space", "WeSpace"]
Authorization: Owner and members can access. Non-members cannot.
"""
type WeSpace implements Space @node(labels: ["Space", "WeSpace"]) {
  id: ID! @id
  name: String!
  visibility: SpaceVisibility!
  createdAt: DateTime!
  owner: [Person!]! @relationship(type: "OWNS", direction: IN)
  members: [SpaceMembership!]! @relationship(type: "HAS_MEMBER", direction: OUT)
  contexts: [FieldContext!]! @relationship(type: "HAS_CONTEXT", direction: OUT)
}

"""
Represents a person or community as a member of a space with a specific role.
Label: ["SpaceMembership"]
"""
type SpaceMembership @node(labels: ["SpaceMembership"]) {
  id: ID! @id
  role: SpaceRole!
  addedAt: DateTime!
  member: [Person!]! @relationship(type: "IS_MEMBER", direction: OUT)
  space: [Space!]! @relationship(type: "HAS_MEMBER", direction: IN)
}

# ============================================================================
# FIELD CONTEXTS (Thematic/Temporal Containers)
# ============================================================================

"""
A thematic or temporal container inside a Space.
Groups related pulses together.
Label: ["FieldContext"]
"""
type FieldContext
  @node(labels: ["FieldContext"])
  @authorization(
    filter: [
      {
        where: {
          node: {
            OR: [
              { meSpace_SOME: { owner_SOME: { id_EQ: "$jwt.user.id" } } }
              {
                meSpace_SOME: {
                  members_SOME: { member_SOME: { id_EQ: "$jwt.user.id" } }
                }
              }
              { weSpace_SOME: { owner_SOME: { id_EQ: "$jwt.user.id" } } }
              {
                weSpace_SOME: {
                  members_SOME: { member_SOME: { id_EQ: "$jwt.user.id" } }
                }
              }
            ]
          }
        }
      }
    ]
  ) {
  id: ID! @id
  title: String!
  emergentName: String
  createdAt: DateTime!
  createdBy: [Person!]! @relationship(type: "CREATED_BY", direction: OUT)
  pulses: [FieldPulse!]! @relationship(type: "HAS_PULSE", direction: OUT)
  meSpace: [MeSpace!]! @relationship(type: "HAS_CONTEXT", direction: IN)
  weSpace: [WeSpace!]! @relationship(type: "HAS_CONTEXT", direction: IN)
  space: [Space!]!
    @cypher(
      statement: """
      MATCH (this)<-[:HAS_CONTEXT]-(space:Space)
      RETURN space
      """
      columnName: "space"
    )
  owner: [Person!]!
    @cypher(
      statement: """
      MATCH (this)<-[:HAS_CONTEXT]-(space:Space)-[:OWNS]->(owner:Person)
      RETURN owner
      """
      columnName: "owner"
    )
}

# ============================================================================
# PULSES (First-Class Citizens - The Write Path)
# ============================================================================

"""
Base pulse type.
Represents a single contributed unit of meaning.
Authorization: Only accessible by users with access to the parent FieldContext's Space.
Never instantiate directly - use concrete types (GoalPulse, ResourcePulse, StoryPulse).
"""
interface FieldPulse {
  id: ID!
  title: String!
  content: String!
  createdAt: DateTime!
  intensity: Float
  createdBy: [Person!]! @declareRelationship
  context: [FieldContext!]! @declareRelationship
}

"""
A pulse that functions as a goal in its context.
Multi-label: ["FieldPulse", "GoalPulse"]
"""
type GoalPulse implements FieldPulse
  @node(labels: ["FieldPulse", "GoalPulse"])
  @authorization(
    filter: [
      {
        where: {
          node: {
            context_SOME: {
              OR: [
                { meSpace_SOME: { owner_SOME: { id_EQ: "$jwt.user.id" } } }
                {
                  meSpace_SOME: {
                    members_SOME: { member_SOME: { id_EQ: "$jwt.user.id" } }
                  }
                }
                { weSpace_SOME: { owner_SOME: { id_EQ: "$jwt.user.id" } } }
                {
                  weSpace_SOME: {
                    members_SOME: { member_SOME: { id_EQ: "$jwt.user.id" } }
                  }
                }
              ]
            }
          }
        }
      }
    ]
  ) {
  id: ID! @id
  title: String!
  content: String!
  createdAt: DateTime!
  intensity: Float
  status: GoalStatus!
  horizon: GoalHorizon
  createdBy: [Person!]! @relationship(type: "CREATED_BY", direction: OUT)
  context: [FieldContext!]! @relationship(type: "HAS_PULSE", direction: IN)
}

# Authorization for pulses is handled through FieldContext.
# When a user queries a pulse through its context relationship, Neo4j GraphQL applies the context's auth rules.

enum GoalStatus {
  ACTIVE
  PAUSED
  COMPLETED
}

enum GoalHorizon {
  SHORT
  MID
  LONG
}

"""
A pulse that functions as a resource in its context.
Multi-label: ["FieldPulse", "ResourcePulse"]
"""
type ResourcePulse implements FieldPulse
  @node(labels: ["FieldPulse", "ResourcePulse"])
  @authorization(
    filter: [
      {
        where: {
          node: {
            context_SOME: {
              OR: [
                { meSpace_SOME: { owner_SOME: { id_EQ: "$jwt.user.id" } } }
                {
                  meSpace_SOME: {
                    members_SOME: { member_SOME: { id_EQ: "$jwt.user.id" } }
                  }
                }
                { weSpace_SOME: { owner_SOME: { id_EQ: "$jwt.user.id" } } }
                {
                  weSpace_SOME: {
                    members_SOME: { member_SOME: { id_EQ: "$jwt.user.id" } }
                  }
                }
              ]
            }
          }
        }
      }
    ]
  ) {
  id: ID! @id
  title: String!
  content: String!
  createdAt: DateTime!
  intensity: Float
  resourceType: String!
  availability: Float
  createdBy: [Person!]! @relationship(type: "CREATED_BY", direction: OUT)
  context: [FieldContext!]! @relationship(type: "HAS_PULSE", direction: IN)
}

"""
Narrative or reflective pulse.
Multi-label: ["FieldPulse", "StoryPulse"]
"""
type StoryPulse implements FieldPulse
  @node(labels: ["FieldPulse", "StoryPulse"])
  @authorization(
    filter: [
      {
        where: {
          node: {
            context_SOME: {
              OR: [
                { meSpace_SOME: { owner_SOME: { id_EQ: "$jwt.user.id" } } }
                {
                  meSpace_SOME: {
                    members_SOME: { member_SOME: { id_EQ: "$jwt.user.id" } }
                  }
                }
                { weSpace_SOME: { owner_SOME: { id_EQ: "$jwt.user.id" } } }
                {
                  weSpace_SOME: {
                    members_SOME: { member_SOME: { id_EQ: "$jwt.user.id" } }
                  }
                }
              ]
            }
          }
        }
      }
    ]
  ) {
  id: ID! @id
  title: String!
  content: String!
  createdAt: DateTime!
  intensity: Float
  createdBy: [Person!]! @relationship(type: "CREATED_BY", direction: OUT)
  context: [FieldContext!]! @relationship(type: "HAS_PULSE", direction: IN)
}

"""
A discovered semantic resonance link between two pulses.
Represents an AI-identified connection with confidence scoring.
Multi-label: ["ResonanceLink"]
"""
type ResonanceLink @node(labels: ["ResonanceLink"]) {
  id: ID! @id
  confidence: Float!
  evidence: String
  mergedFrom: String
  createdAt: DateTime!
  source: [FieldPulse!]! @relationship(type: "SOURCE", direction: OUT)
  target: [FieldPulse!]! @relationship(type: "TARGET", direction: OUT)
  pattern: [FieldResonance!]!
    @relationship(type: "RESONATES_AS", direction: OUT)
}

"""
A discovered pattern of semantic resonance between pulses.
Multi-label: ["FieldResonance"]
"""
type FieldResonance @node(labels: ["FieldResonance"]) {
  id: ID! @id
  label: String!
  description: String
  confidence: Float
  source: [FieldPulse!]! @relationship(type: "SOURCE", direction: OUT)
  target: [FieldPulse!]! @relationship(type: "TARGET", direction: OUT)
  detectedBy: [Person!]! @relationship(type: "DETECTED_BY", direction: OUT)
  links: [ResonanceLink!]! @relationship(type: "RESONATES_AS", direction: IN)
}

# ============================================================================
# SEARCH LAYER (Cross-Entity Discovery)
# ============================================================================

"""
Structured response for categorized search results.
Returns up to 10 results of each entity type matching the search query.
"""
type SearchResults {
  people: [Person!]!
  communities: [Community!]!
  meSpaces: [MeSpace!]!
  weSpaces: [WeSpace!]!
  contexts: [FieldContext!]!
  goalPulses: [GoalPulse!]!
  resourcePulses: [ResourcePulse!]!
  storyPulses: [StoryPulse!]!
}

# ============================================================================
# MUTATIONS (Custom Operations)
# ============================================================================

"""
Response from the chatbot containing the message and session ID.
"""
type ChatbotResponse {
  message: String!
  sessionId: String!
}

"""
Response when adding a member to a space.
"""
type AddSpaceMemberResponse {
  success: Boolean!
  message: String!
  membership: SpaceMembership
}

"""
Response when updating a space member's role.
"""
type UpdateSpaceMemberRoleResponse {
  success: Boolean!
  message: String!
  membership: SpaceMembership
}

"""
Response when removing a member from a space.
"""
type RemoveSpaceMemberResponse {
  success: Boolean!
  message: String!
}

"""
Response when updating user AI preferences.
"""
type UpdateUserAIResponse {
  success: Boolean!
  message: String!
  user: User
}

type Mutation {
  """
  Send a message to the chatbot and receive a response.
  Placeholder for future chatbot functionality.
  """
  sendMessageToChatbot(message: String!, sessionId: String): ChatbotResponse

  """
  Invite a person to join the platform.
  Sends an invite email with a password reset link.
  """
  invitePerson(personId: String!): Person

  """
  Cancel an invitation for a person.
  Removes the User label and invite-related properties.
  """
  cancelInvite(personId: String!): Person

  """
  Add a member to a space with a specific role.
  Only the space owner or members with ADMIN role can add new members.
  """
  addSpaceMember(
    spaceId: ID!
    memberId: ID!
    role: SpaceRole!
  ): AddSpaceMemberResponse!

  """
  Update a space member's role.
  Only the space owner or members with ADMIN role can change roles.
  """
  updateSpaceMemberRole(
    spaceId: ID!
    memberId: ID!
    role: SpaceRole!
  ): UpdateSpaceMemberRoleResponse!

  """
  Remove a member from a space.
  Only the space owner or members with ADMIN role can remove members.
  Cannot remove the space owner.
  """
  removeSpaceMember(spaceId: ID!, memberId: ID!): RemoveSpaceMemberResponse!

  """
  Update AI functionality preferences for a user.
  Users can enable or disable AI features in the application.
  """
  updateUserAI(userId: ID!, aiEnabled: Boolean!): UpdateUserAIResponse!
}

type Query {
  """
  Global federated search across all entity types.
  Searches using case-insensitive substring matching on:
    - Pulses: content field
    - People: firstName, lastName, email
    - Contexts: title field
    - Spaces (MeSpace/WeSpace): name field (filtered by user ownership/membership)
    - Communities: name field

  Space Filtering:
    - Only returns spaces where the current user is the owner OR a member with any role (ADMIN, MEMBER, or GUEST)
    - Private spaces not owned or joined by the user are excluded from results

  Args:
    - query: Search term (required, case-insensitive substring match)

  Returns: SearchResults with up to 10 results of each entity type
  """
  searchAll(query: String!): SearchResults
}

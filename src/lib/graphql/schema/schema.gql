# GoalPost GraphQL Schema - Neo4j GraphQL
# Designed for pulse-first, context-aware relational data modeling.
#
# Architecture:
# - Pulses are the write path (first-class citizens)
# - Resonance is the read/insight path (AI-generated meaning)
# - Spaces define privacy boundaries (MeSpace/WeSpace)
# - AI adds meaning after the fact (explainability layer)

extend schema @authentication

# ============================================================================
# CORE ACTORS (Who initiates pulses & owns spaces)
# ============================================================================

"""
A human user of the system.
Multi-label: ["Person", "User"]
"""
type Person @node(labels: ["Person"]) {
  id: ID! @id
  firstName: String!
  lastName: String!
  name: String! @customResolver(requires: "firstName lastName")
  email: String
  ownsSpaces: [Space!]! @relationship(type: "OWNS", direction: OUT)
}

"""
A collective identity (team, family, cohort, etc).
Has members and can own spaces and initiate pulses.
Multi-label: ["Community"]
"""
type Community @node(labels: ["Community"]) {
  id: ID! @id
  name: String!
  type: String
  members: [LifeSensor!]! @relationship(type: "HAS_MEMBER", direction: OUT)
  ownsSpaces: [Space!]! @relationship(type: "OWNS", direction: OUT)
}

"""
Anything that can initiate pulses or own spaces.
Query-time abstraction - either a Person or Community.
"""
union LifeSensor = Person | Community

# ============================================================================
# SPACES (Privacy + Ownership Boundary)
# ============================================================================

"""
Role-based permission for space membership.
VIEW: Can read pulses and contexts in the space
EDIT: Can modify pulses and contexts in the space
"""
enum SpaceRole {
  VIEW
  EDIT
}

"""
Abstract space type.
Never instantiated directly - use MeSpace or WeSpace.
"""
interface Space {
  id: ID!
  name: String!
  visibility: SpaceVisibility!
  createdAt: DateTime!
}

enum SpaceVisibility {
  PRIVATE
  SHARED
}

"""
A personal space owned by one person or community.
Can be private (only owner) or shared with specific members.
Multi-label: ["Space", "MeSpace"]
"""
type MeSpace implements Space @node(labels: ["Space", "MeSpace"]) {
  id: ID! @id
  name: String!
  visibility: SpaceVisibility!
  createdAt: DateTime!
  owner: [LifeSensor!]! @relationship(type: "OWNS", direction: IN)
  members: [SpaceMembership!]! @relationship(type: "HAS_MEMBER", direction: OUT)
  contexts: [FieldContext!]! @relationship(type: "HAS_CONTEXT", direction: OUT)
}

"""
A collaborative space shared with other people.
Has an owner and members who can all participate.
Multi-label: ["Space", "WeSpace"]
"""
type WeSpace implements Space @node(labels: ["Space", "WeSpace"]) {
  id: ID! @id
  name: String!
  visibility: SpaceVisibility!
  createdAt: DateTime!
  owner: [LifeSensor!]! @relationship(type: "OWNS", direction: IN)
  members: [SpaceMembership!]! @relationship(type: "HAS_MEMBER", direction: OUT)
  contexts: [FieldContext!]! @relationship(type: "HAS_CONTEXT", direction: OUT)
}

"""
Represents a person or community as a member of a space with a specific role.
Label: ["SpaceMembership"]
"""
type SpaceMembership @node(labels: ["SpaceMembership"]) {
  id: ID! @id
  role: SpaceRole!
  addedAt: DateTime!
  member: [LifeSensor!]! @relationship(type: "IS_MEMBER", direction: OUT)
}

# ============================================================================
# FIELD CONTEXTS (Thematic/Temporal Containers)
# ============================================================================

"""
A thematic or temporal container inside a Space.
Groups related pulses together.
Label: ["FieldContext"]
"""
type FieldContext @node(labels: ["FieldContext"]) {
  id: ID! @id
  title: String!
  emergentName: String
  createdAt: DateTime!
  pulses: [FieldPulse!]! @relationship(type: "HAS_PULSE", direction: OUT)
  space: [Space!]! @relationship(type: "HAS_CONTEXT", direction: IN)
}

# ============================================================================
# PULSES (First-Class Citizens - The Write Path)
# ============================================================================

"""
Base pulse type.
Represents a single contributed unit of meaning.
Never instantiate directly - use concrete types (GoalPulse, ResourcePulse, StoryPulse).
"""
interface FieldPulse {
  id: ID!
  content: String!
  createdAt: DateTime!
  intensity: Float
}

"""
A pulse that functions as a goal in its context.
Multi-label: ["FieldPulse", "GoalPulse"]
"""
type GoalPulse implements FieldPulse
  @node(labels: ["FieldPulse", "GoalPulse"]) {
  id: ID! @id
  content: String!
  createdAt: DateTime!
  intensity: Float
  status: GoalStatus!
  horizon: GoalHorizon
  initiatedBy: [LifeSensor!]!
    @relationship(type: "INITIATED_BY", direction: OUT)
  context: [FieldContext!]! @relationship(type: "HAS_PULSE", direction: IN)
}

enum GoalStatus {
  ACTIVE
  PAUSED
  COMPLETED
}

enum GoalHorizon {
  SHORT
  MID
  LONG
}

"""
A pulse that functions as a resource in its context.
Multi-label: ["FieldPulse", "ResourcePulse"]
"""
type ResourcePulse implements FieldPulse
  @node(labels: ["FieldPulse", "ResourcePulse"]) {
  id: ID! @id
  content: String!
  createdAt: DateTime!
  intensity: Float
  resourceType: String!
  availability: Float
  initiatedBy: [LifeSensor!]!
    @relationship(type: "INITIATED_BY", direction: OUT)
  context: [FieldContext!]! @relationship(type: "HAS_PULSE", direction: IN)
}

"""
Narrative or reflective pulse.
Multi-label: ["FieldPulse", "StoryPulse"]
"""
type StoryPulse implements FieldPulse
  @node(labels: ["FieldPulse", "StoryPulse"]) {
  id: ID! @id
  content: String!
  createdAt: DateTime!
  intensity: Float
  initiatedBy: [LifeSensor!]!
    @relationship(type: "INITIATED_BY", direction: OUT)
  context: [FieldContext!]! @relationship(type: "HAS_PULSE", direction: IN)
}

# ============================================================================
# RESONANCE LAYER (AI + Meaning - The Read Path)
# ============================================================================

"""
A semantic or symbolic pattern discovered across pulses.
Usually AI-generated.
Label: ["FieldResonance"]
"""
type FieldResonance @node(labels: ["FieldResonance"]) {
  id: ID! @id
  label: String!
  description: String
}

"""
A justified resonance connection between two pulses.
This is the explainability layer for AI-generated insights.
Label: ["ResonanceLink"]
"""
type ResonanceLink @node(labels: ["ResonanceLink"]) {
  id: ID! @id
  confidence: Float!
  evidence: String
  createdAt: DateTime!
  source: [FieldPulse!]! @relationship(type: "SOURCE", direction: OUT)
  target: [FieldPulse!]! @relationship(type: "TARGET", direction: OUT)
  resonance: [FieldResonance!]!
    @relationship(type: "RESONATES_AS", direction: OUT)
  detectedBy: [LifeSensor!]! @relationship(type: "DETECTED_BY", direction: OUT)
}

# ============================================================================
# SEARCH LAYER (Cross-Entity Discovery)
# ============================================================================

"""
Structured response for categorized search results.
Returns up to 10 results of each entity type matching the search query.
"""
type SearchResults {
  people: [Person!]!
  communities: [Community!]!
  meSpaces: [MeSpace!]!
  weSpaces: [WeSpace!]!
  contexts: [FieldContext!]!
  goalPulses: [GoalPulse!]!
  resourcePulses: [ResourcePulse!]!
  storyPulses: [StoryPulse!]!
}

# ============================================================================
# MUTATIONS (Custom Operations)
# ============================================================================

"""
Response from the chatbot containing the message and session ID.
"""
type ChatbotResponse {
  message: String!
  sessionId: String!
}

type Mutation {
  """
  Send a message to the chatbot and receive a response.
  Placeholder for future chatbot functionality.
  """
  sendMessageToChatbot(message: String!, sessionId: String): ChatbotResponse

  """
  Invite a person to join the platform.
  Sends an invite email with a password reset link.
  """
  invitePerson(personId: String!): Person

  """
  Cancel an invitation for a person.
  Removes the User label and invite-related properties.
  """
  cancelInvite(personId: String!): Person
}

type Query {
  """
  Global federated search across all entity types.
  Searches using case-insensitive substring matching on:
    - Pulses: content field
    - People: firstName, lastName, email
    - Contexts: title field
    - Spaces (MeSpace/WeSpace): name field (filtered by user ownership/membership)
    - Communities: name field

  Space Filtering:
    - Only returns spaces where the current user is the owner OR a member with any role (VIEW or EDIT)
    - Private spaces not owned or joined by the user are excluded from results

  Args:
    - query: Search term (required, case-insensitive substring match)

  Returns: SearchResults with up to 10 results of each entity type
  """
  searchAll(query: String!): SearchResults
}

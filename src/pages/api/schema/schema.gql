# Migration to OWL Ontology v.2.3
# This schema has been updated to reflect the GoalPost OWL ontology (http://goalpost.earth/ontology#).
# Key changes:
# - Introduced ontology-inspired interfaces and types (e.g., RelationalEntity, LifeSensor, FieldContext).
# - Mapped existing types to ontology classes (e.g., Person implements LifeSensor, CarePoint becomes FieldContext).
# - Added ontology properties as fields/relationships (e.g., actsAs, withinContext, feelsLike).
# - Shifted from rigid node types to fluid relational expressions, allowing entities to play multiple roles.
# - Added extensive comments for clarity on ontology mappings and changes.

enum Status {
  ACTIVE
  INACTIVE
  PENDING
}

# Ontology-inspired interfaces and types
# RelationalEntity: Base class for dynamic entities that can play multiple roles.
interface RelationalEntity {
  id: ID!
  name: String
  description: String
  # Ontology property: expandsInto - captures transformation/evolution.
  expandsInto: [RelationalEntity!]!
    @relationship(type: "EXPANDS_INTO", direction: OUT)
  # Ontology property: feelsLike - poetic/symbolic resonance.
  feelsLike: [FieldResonance!]!
    @relationship(type: "FEELS_LIKE", direction: OUT)
  createdAt: DateTime!
  updatedAt: DateTime
}

# LifeSensor: Entities that initiate or sense relational shifts (subclass of RelationalEntity).
interface LifeSensor {
  # Copied from RelationalEntity
  id: ID!
  name: String
  description: String
  expandsInto: [RelationalEntity!]!
    @relationship(type: "EXPANDS_INTO", direction: OUT)
  feelsLike: [FieldResonance!]!
    @relationship(type: "FEELS_LIKE", direction: OUT)
  createdAt: DateTime!
  updatedAt: DateTime
  # Own property
  sensingModality: SensingModality
    @relationship(type: "HAS_SENSING_MODALITY", direction: OUT)
}

# FieldContext: Contexts holding relational unfolding (e.g., former CarePoints).
# Removed interface to avoid naming conflicts; using type directly.

# RoleExpression: Contextual roles entities play (e.g., GoalRole, ResourceRole).
interface RoleExpression {
  id: ID! @id
  name: String!
  description: String
  # Ontology property: withinContext - ties to FieldContext.
  context: FieldContextNode
    @relationship(type: "WITHIN_CONTEXT", direction: OUT)
  createdAt: DateTime!
}

# Specific role types (subclasses of RoleExpression).
type GoalRole implements RoleExpression @node {
  id: ID! @id
  name: String!
  description: String
  context: FieldContextNode
    @relationship(type: "WITHIN_CONTEXT", direction: OUT)
  createdAt: DateTime!
}

type ResourceRole implements RoleExpression @node {
  id: ID! @id
  name: String!
  description: String
  context: FieldContextNode
    @relationship(type: "WITHIN_CONTEXT", direction: OUT)
  createdAt: DateTime!
}

type StoryRole implements RoleExpression @node {
  id: ID! @id
  name: String!
  description: String
  context: FieldContextNode
    @relationship(type: "WITHIN_CONTEXT", direction: OUT)
  createdAt: DateTime!
}

# FieldPulse: Sensed shifts in the field.
interface FieldPulse {
  id: ID! @id
  name: String
  description: String
  # Ontology property: initiatedBy - who/what initiated.
  initiatedBy: LifeSensor @relationship(type: "INITIATED_BY", direction: IN)
  # Ontology property: alignedWith - resonance expressed.
  alignedWith: FieldResonance
    @relationship(type: "ALIGNED_WITH", direction: OUT)
  # Ontology property: intensity - how strongly felt.
  intensity: Float
  # Ontology property: why - motivation/reason.
  why: String
  context: FieldContextNode @relationship(type: "HELD_WITHIN", direction: OUT)
  createdAt: DateTime!
}

# Subclasses of FieldPulse.
type TimePulse implements FieldPulse @node {
  id: ID! @id
  name: String
  description: String
  initiatedBy: LifeSensor @relationship(type: "INITIATED_BY", direction: IN)
  alignedWith: FieldResonance
    @relationship(type: "ALIGNED_WITH", direction: OUT)
  intensity: Float
  why: String
  context: FieldContextNode @relationship(type: "HELD_WITHIN", direction: OUT)
  createdAt: DateTime!
}

type CarePulse implements FieldPulse @node {
  id: ID! @id
  name: String
  description: String
  initiatedBy: LifeSensor @relationship(type: "INITIATED_BY", direction: IN)
  alignedWith: FieldResonance
    @relationship(type: "ALIGNED_WITH", direction: OUT)
  intensity: Float
  why: String
  context: FieldContextNode @relationship(type: "HELD_WITHIN", direction: OUT)
  createdAt: DateTime!
}

# FieldResonance: Archetypal patterns threading pulses.
interface FieldResonance {
  id: ID! @id
  name: String!
  description: String
  why: String
  createdAt: DateTime!
}

# SensingModality: How sensors perceive.
type SensingModality @node {
  id: ID! @id
  name: String!
  description: String
  createdAt: DateTime!
}

# ReciprocalOffering: Gestures of gratitude/care.
interface ReciprocalOffering {
  id: ID! @id
  description: String
  # Ontology property: receivedBy - who receives.
  receivedBy: LifeSensor @relationship(type: "RECEIVED_BY", direction: IN)
  # Ontology property: recognizesPulse - pulse acknowledged.
  recognizesPulse: FieldPulse
    @relationship(type: "RECOGNIZES_PULSE", direction: OUT)
  createdAt: DateTime!
}

# HonorariumOffering: Subclass with reciprocity pattern.
type HonorariumOffering implements ReciprocalOffering @node {
  id: ID! @id
  description: String
  receivedBy: LifeSensor @relationship(type: "RECEIVED_BY", direction: IN)
  recognizesPulse: FieldPulse
    @relationship(type: "RECOGNIZES_PULSE", direction: OUT)
  # Ontology property: reciprocityPattern.
  reciprocityPattern: String
  createdAt: DateTime!
}

interface PersonInterface {
  # Copied from RelationalEntity
  id: ID!
  name: String
  description: String
  expandsInto: [RelationalEntity!]!
    @relationship(type: "EXPANDS_INTO", direction: OUT)
  feelsLike: [FieldResonance!]!
    @relationship(type: "FEELS_LIKE", direction: OUT)
  createdAt: DateTime!
  updatedAt: DateTime
  # Copied from LifeSensor
  sensingModality: SensingModality
    @relationship(type: "HAS_SENSING_MODALITY", direction: OUT)
  # Own
  firstName: String!
  lastName: String!
  photo: String
  phone: String
  email: String
  pronouns: String
  location: String
}
extend schema @authentication

type Person implements PersonInterface @node {
  id: ID! @id
  isUser: Boolean
    @cypher(
      statement: """
      MATCH (this) WHERE this:User
      RETURN true AS isUser
      """
      columnName: "isUser"
    )
  firstName: String!
  lastName: String!
  name: String! @customResolver(requires: "firstName lastName")
  photo: String
  phone: String
  email: String
  pronouns: String
  location: String
  inviteSent: Boolean

  # Ontology: actsAs - how entity expresses roles in fields.
  actsAs: [RoleExpression!]! @relationship(type: "ACTS_AS", direction: OUT)
  # Ontology: expandsInto - transformation/evolution.
  expandsInto: [RelationalEntity!]!
    @relationship(type: "EXPANDS_INTO", direction: OUT)
  # Ontology: feelsLike - resonance.
  feelsLike: [FieldResonance!]!
    @relationship(type: "FEELS_LIKE", direction: OUT)
  # Ontology: hasSensingModality.
  sensingModality: SensingModality
    @relationship(type: "HAS_SENSING_MODALITY", direction: OUT)

  # Legacy relationships, reinterpreted via ontology.
  # Connections now as FieldContribution in shared FieldContext.
  connections: [Person!]!
    @relationship(
      type: "CONNECTED_TO"
      direction: OUT
      queryDirection: UNDIRECTED
      properties: "ConnectedTo"
    )

  status: String!
  careManual: String
  avatar: String
  favorites: String
  passions: String
  traits: String
  fieldsOfCare: String
  interests: String

  # CoreValues reinterpreted as feelsLike resonances.
  coreValues: [CoreValue!]! @relationship(type: "EMBRACES", direction: OUT)
  # CarePoints now FieldContexts.
  contexts: [FieldContextNode!]!
    @cypher(
      statement: """
      MATCH (this)-[:MOTIVATED_BY]->(:Goal)-[:ENABLED_BY|CARES_FOR]-(goalContexts:FieldContextNode)
      WITH goalContexts AS context
      RETURN DISTINCT context
      UNION
      MATCH (this)-[:PROVIDES]->(resource:Resource)-[:APPLIED_IN]->(resourceContext:FieldContextNode)
      WITH resourceContext AS context
      RETURN DISTINCT context
      """
      columnName: "context"
    )
  # Goals via actsAs GoalRole.
  goals: [Goal!]! @relationship(type: "MOTIVATED_BY", direction: OUT)
  providesResources: [Resource!]!
    @relationship(type: "PROVIDES", direction: OUT)
  communities: [Community!]!
    @relationship(type: "BELONGS_TO", direction: OUT, properties: "BelongsTo")

  createdBy: [Person!]! @relationship(type: "CREATED_BY", direction: OUT)
  createdAt: DateTime!
    @timestamp(operations: [CREATE])
    @settable(onCreate: true, onUpdate: false)
  updatedAt: DateTime
    @timestamp(operations: [UPDATE])
    @settable(onCreate: false, onUpdate: true)
}

type ConnectedTo @relationshipProperties {
  why: String
  interests: String
}

type BelongsTo @relationshipProperties {
  totem: String
  signupDate: Date
}

# CarePoint migrated to FieldContext (ontology class).
# FieldContext: Holds relational unfolding, formerly rigid CarePoints.
type FieldContextNode @node {
  id: ID! @id
  name: String!
  description: String
  # Ontology: hasEmergentName.
  emergentName: String
  status: String!
  why: String
  location: String
  time: String
  levelFulfilled: String
  fulfillmentDate: String
  successMeasures: String
  issuesIdentified: String
  issuesResolved: String
  # Ontology: pulses held within.
  pulses: [FieldPulse!]! @relationship(type: "HELD_WITHIN", direction: IN)

  # Legacy relationships reinterpreted.
  # Resources as RelationalEntity in ResourceRole.
  resources: [Resource!]! @relationship(type: "DEPENDS_ON", direction: OUT)
  # Goals enabled/cares for.
  enabledByGoals: [Goal!]! @relationship(type: "ENABLES", direction: IN)
  caresForGoals: [Goal!]! @relationship(type: "CARES_FOR", direction: OUT)

  createdBy: [Person!]! @relationship(type: "CREATED_BY", direction: OUT)
  createdAt: DateTime!
    @timestamp(operations: [CREATE])
    @settable(onCreate: true, onUpdate: false)
  updatedAt: DateTime
    @timestamp(operations: [UPDATE])
    @settable(onCreate: false, onUpdate: true)
}

# Community migrated to implement FieldContext and LifeSensor (ontology subclasses).
type Community implements LifeSensor @node {
  id: ID! @id
  name: String!
  description: String
  # Ontology: hasEmergentName.
  emergentName: String
  why: String
  location: String
  time: String
  activities: String
  resultsAchieved: String
  status: String!
  # Ontology: RelationalEntity properties.
  expandsInto: [RelationalEntity!]!
    @relationship(type: "EXPANDS_INTO", direction: OUT)
  feelsLike: [FieldResonance!]!
    @relationship(type: "FEELS_LIKE", direction: OUT)
  # Ontology: LifeSensor property.
  sensingModality: SensingModality
    @relationship(type: "HAS_SENSING_MODALITY", direction: OUT)
  # Ontology: pulses.
  pulses: [FieldPulse!]! @relationship(type: "HELD_WITHIN", direction: IN)

  # Legacy relationships.
  members: [Person!]! @relationship(type: "BELONGS_TO", direction: IN)
  relatedCommunities: [Community!]!
    @relationship(
      type: "RELATES_TO"
      direction: OUT
      queryDirection: UNDIRECTED
    )
  resources: [Resource!]! @relationship(type: "HAS_ACCESS_TO", direction: OUT)
  goals: [Goal!]! @relationship(type: "MOTIVATED_BY", direction: OUT)
  coreValues: [CoreValue!]! @relationship(type: "EMBRACES", direction: OUT)

  createdBy: [Person!]! @relationship(type: "CREATED_BY", direction: OUT)
  createdAt: DateTime!
    @timestamp(operations: [CREATE])
    @settable(onCreate: true, onUpdate: false)
  updatedAt: DateTime
    @timestamp(operations: [UPDATE])
    @settable(onCreate: false, onUpdate: true)
}

# CoreValue mapped to FieldResonance (ontology class).
type CoreValue implements FieldResonance @node {
  id: ID! @id
  name: String!
  alignmentChallenges: String
  alignmentExamples: String
  description: String
  why: String
  # Ontology: feelsLike connections.
  people: [Person!]! @relationship(type: "EMBRACES", direction: IN)
  goals: [Goal!]! @relationship(type: "ALIGNED_TO", direction: IN)
  communities: [Community!]! @relationship(type: "EMBRACES", direction: IN)

  createdBy: [Person!]! @relationship(type: "CREATED_BY", direction: OUT)
  createdAt: DateTime!
    @timestamp(operations: [CREATE])
    @settable(onCreate: true, onUpdate: false)
  updatedAt: DateTime
    @timestamp(operations: [UPDATE])
    @settable(onCreate: false, onUpdate: true)
}

type Goal implements RelationalEntity @node {
  id: ID! @id
  name: String!
  description: String
  successMeasures: String
  photo: String
  activities: String
  status: String!
  why: String
  location: String
  time: String
  # Ontology: actsAs - entity expresses as GoalRole.
  actsAs: [RoleExpression!]! @relationship(type: "ACTS_AS", direction: IN) # Inverted for context.
  # Ontology: expandsInto.
  expandsInto: [RelationalEntity!]!
    @relationship(type: "EXPANDS_INTO", direction: OUT)
  # Ontology: feelsLike.
  feelsLike: [FieldResonance!]!
    @relationship(type: "FEELS_LIKE", direction: OUT)

  # Legacy relationships.
  resources: [Resource!]! @relationship(type: "APPLIED_TO", direction: IN)
  motivatesPeople: [Person!]! @relationship(type: "MOTIVATED_BY", direction: IN)
  motivatesCommunities: [Community!]!
    @relationship(type: "MOTIVATED_BY", direction: IN)
  coreValues: [CoreValue!]! @relationship(type: "ALIGNED_TO", direction: OUT)
  enablesContexts: [FieldContextNode!]!
    @relationship(type: "ENABLES", direction: OUT)
  caredForByContexts: [FieldContextNode!]!
    @relationship(type: "CARES_FOR", direction: IN)

  createdBy: [Person!]! @relationship(type: "CREATED_BY", direction: OUT)
  createdAt: DateTime!
    @timestamp(operations: [CREATE])
    @settable(onCreate: true, onUpdate: false)
  updatedAt: DateTime
    @timestamp(operations: [UPDATE])
    @settable(onCreate: false, onUpdate: true)
}

type Resource implements RelationalEntity @node {
  id: ID! @id
  name: String!
  description: String
  status: String!
  why: String
  location: String
  time: String
  # Ontology: actsAs ResourceRole.
  actsAs: [RoleExpression!]! @relationship(type: "ACTS_AS", direction: IN)
  # Ontology: expandsInto.
  expandsInto: [RelationalEntity!]!
    @relationship(type: "EXPANDS_INTO", direction: OUT)
  # Ontology: feelsLike.
  feelsLike: [FieldResonance!]!
    @relationship(type: "FEELS_LIKE", direction: OUT)

  # Legacy relationships.
  contexts: [FieldContextNode!]!
    @relationship(type: "DEPENDS_ON", direction: IN)
  goals: [Goal!]! @relationship(type: "APPLIED_TO", direction: OUT)
  resources: [Resource!]! @relationship(type: "DEPENDS_ON", direction: IN)
  providedByPerson: [Person!]! @relationship(type: "PROVIDES", direction: IN)
  providedByCommunity: [Community!]!
    @relationship(type: "PROVIDES", direction: IN)

  createdBy: [Person!]! @relationship(type: "CREATED_BY", direction: OUT)
  createdAt: DateTime!
    @timestamp(operations: [CREATE])
    @settable(onCreate: true, onUpdate: false)
  updatedAt: DateTime
    @timestamp(operations: [UPDATE])
    @settable(onCreate: false, onUpdate: true)
}

# Log migrated to FieldContribution (ontology class).
type FieldContribution @node {
  id: ID! @id
  description: String!
  # Ontology: withinContext.
  context: FieldContextNode
    @relationship(type: "WITHIN_CONTEXT", direction: OUT)
  createdBy: [Person!]! @relationship(type: "CREATED_BY", direction: OUT)
  # Legacy: loggedFor goals/contexts/resources.
  goals: [Goal!]! @relationship(type: "LOGGED_FOR", direction: OUT)
  contexts: [FieldContextNode!]!
    @relationship(type: "LOGGED_FOR", direction: OUT)
  resources: [Resource!]! @relationship(type: "LOGGED_FOR", direction: OUT)
  createdAt: DateTime!
    @timestamp(operations: [CREATE])
    @settable(onCreate: true, onUpdate: false)
}

type ChatbotResponse {
  message: String!
  sessionId: String!
}

type Mutation {
  generatePersonEmbeddings(personId: ID!): Boolean!
  sendMessageToChatbot(message: String!, sessionId: String): ChatbotResponse!
  invitePerson(personId: ID!): Person!
  cancelInvite(personId: ID!): Person!
}

type Query {
  peopleSubstringSearch(key: String!): [Person!]!
    @cypher(
      statement: """
      MATCH (person:Person)
      WHERE toLower(person.firstName) CONTAINS toLower($key) OR toLower(person.lastName) CONTAINS toLower($key)
      RETURN person
      """
      columnName: "person"
    )
  communitySubstringSearch(key: String!): [Community!]!
    @cypher(
      statement: """
      MATCH (community:Community)
      WHERE toLower(community.name) CONTAINS toLower($key)
      OR toLower(community.description) CONTAINS toLower($key)
      RETURN community
      """
      columnName: "community"
    )
  coreValueSubstringSearch(key: String!): [CoreValue!]!
    @cypher(
      statement: """
      MATCH (coreValue:CoreValue)
      WHERE toLower(coreValue.name) CONTAINS toLower($key)
      OR toLower(coreValue.description) CONTAINS toLower($key)
      RETURN coreValue
      """
      columnName: "coreValue"
    )
  goalSubstringSearch(key: String!): [Goal!]!
    @cypher(
      statement: """
      MATCH (goal:Goal)
      WHERE toLower(goal.name) CONTAINS toLower($key)
      OR toLower(goal.description) CONTAINS toLower($key)
      RETURN goal
      """
      columnName: "goal"
    )
  resourceSubstringSearch(key: String!): [Resource!]!
    @cypher(
      statement: """
      MATCH (resource:Resource)
      WHERE toLower(resource.name) CONTAINS toLower($key)
      OR toLower(resource.description) CONTAINS toLower($key)
      RETURN resource
      """
      columnName: "resource"
    )
  # Updated: carePointSubstringSearch to contextSubstringSearch for FieldContext.
  contextSubstringSearch(key: String!): [FieldContextNode!]!
    @cypher(
      statement: """
      MATCH (context:FieldContextNode)
      WHERE toLower(context.description) CONTAINS toLower($key)
      RETURN context
      """
      columnName: "context"
    )
}

"""
GoalPost GraphQL Schema - Neo4j GraphQL
Designed for pulse-first, context-aware relational data modeling.

Architecture:
- Pulses are the write path (first-class citizens)
- Resonance is the read/insight path (AI-generated meaning)
- Spaces define privacy boundaries (MeSpace/WeSpace)
- AI adds meaning after the fact (explainability layer)
"""

extend schema @authentication

# ============================================================================
# CORE ACTORS (Who initiates pulses & owns spaces)
# ============================================================================

"""
A human user of the system.
Multi-label: ["Person", "LifeSensor", "RelationalEntity"]
"""
type Person
  @node(labels: ["Person", "LifeSensor", "RelationalEntity"]) {
  id: ID! @id @unique
  name: String!
  email: String
  ownsSpaces: [Space!]!
    @relationship(type: "OWNS", direction: OUT)
}

"""
A collective identity (team, family, cohort, etc).
Can own spaces and initiate pulses.
Multi-label: ["Community", "LifeSensor", "RelationalEntity"]
"""
type Community
  @node(labels: ["Community", "LifeSensor", "RelationalEntity"]) {
  id: ID! @id @unique
  name: String!
  type: String
  ownsSpaces: [Space!]!
    @relationship(type: "OWNS", direction: OUT)
}

"""
Anything that can initiate pulses or own spaces.
Never instantiated directly - use Person or Community.
"""
interface LifeSensor {
  id: ID!
}

# ============================================================================
# SPACES (Privacy + Ownership Boundary)
# ============================================================================

"""
Abstract space type.
Never instantiated directly - use MeSpace or WeSpace.
"""
interface Space {
  id: ID!
  name: String!
  visibility: SpaceVisibility!
  createdAt: DateTime!
  contexts: [FieldContext!]!
  owner: LifeSensor!
}

enum SpaceVisibility {
  PRIVATE
  SHARED
}

"""
A private space owned by exactly one person or community.
Multi-label: ["Space", "MeSpace"]
"""
type MeSpace implements Space
  @node(labels: ["Space", "MeSpace"]) {
  id: ID! @id @unique
  name: String!
  visibility: SpaceVisibility!
  createdAt: DateTime!
  owner: LifeSensor!
    @relationship(type: "OWNS", direction: IN)
  contexts: [FieldContext!]!
    @relationship(type: "HAS_CONTEXT", direction: OUT)
}

"""
A shared space with an owner and members.
Multi-label: ["Space", "WeSpace"]
"""
type WeSpace implements Space
  @node(labels: ["Space", "WeSpace"]) {
  id: ID! @id @unique
  name: String!
  visibility: SpaceVisibility!
  createdAt: DateTime!
  owner: LifeSensor!
    @relationship(type: "OWNS", direction: IN)
  members: [LifeSensor!]!
    @relationship(type: "HAS_MEMBER", direction: OUT)
  contexts: [FieldContext!]!
    @relationship(type: "HAS_CONTEXT", direction: OUT)
}

# ============================================================================
# FIELD CONTEXTS (Thematic/Temporal Containers)
# ============================================================================

"""
A thematic or temporal container inside a Space.
Groups related pulses together.
Label: ["FieldContext"]
"""
type FieldContext
  @node(labels: ["FieldContext"]) {
  id: ID! @id @unique
  title: String!
  emergentName: String
  createdAt: DateTime!
  pulses: [FieldPulse!]!
    @relationship(type: "HAS_PULSE", direction: OUT)
  space: Space!
    @relationship(type: "HAS_CONTEXT", direction: IN)
}

# ============================================================================
# PULSES (First-Class Citizens - The Write Path)
# ============================================================================

"""
Base pulse type.
Represents a single contributed unit of meaning.
Never instantiate directly - use concrete types (GoalPulse, ResourcePulse, StoryPulse).
"""
interface FieldPulse {
  id: ID!
  content: String!
  createdAt: DateTime!
  intensity: Float
  initiatedBy: LifeSensor!
  context: FieldContext!
}

"""
A pulse that functions as a goal in its context.
Multi-label: ["FieldPulse", "GoalPulse"]
"""
type GoalPulse implements FieldPulse
  @node(labels: ["FieldPulse", "GoalPulse"]) {
  id: ID! @id @unique
  content: String!
  createdAt: DateTime!
  intensity: Float
  status: GoalStatus!
  horizon: GoalHorizon
  initiatedBy: LifeSensor!
    @relationship(type: "INITIATED_BY", direction: OUT)
  context: FieldContext!
    @relationship(type: "HAS_PULSE", direction: IN)
}

enum GoalStatus {
  ACTIVE
  PAUSED
  COMPLETED
}

enum GoalHorizon {
  SHORT
  MID
  LONG
}

"""
A pulse that functions as a resource in its context.
Multi-label: ["FieldPulse", "ResourcePulse"]
"""
type ResourcePulse implements FieldPulse
  @node(labels: ["FieldPulse", "ResourcePulse"]) {
  id: ID! @id @unique
  content: String!
  createdAt: DateTime!
  intensity: Float
  resourceType: String!
  availability: Float
  initiatedBy: LifeSensor!
    @relationship(type: "INITIATED_BY", direction: OUT)
  context: FieldContext!
    @relationship(type: "HAS_PULSE", direction: IN)
}

"""
Narrative or reflective pulse.
Multi-label: ["FieldPulse", "StoryPulse"]
"""
type StoryPulse implements FieldPulse
  @node(labels: ["FieldPulse", "StoryPulse"]) {
  id: ID! @id @unique
  content: String!
  createdAt: DateTime!
  intensity: Float
  initiatedBy: LifeSensor!
    @relationship(type: "INITIATED_BY", direction: OUT)
  context: FieldContext!
    @relationship(type: "HAS_PULSE", direction: IN)
}

# ============================================================================
# RESONANCE LAYER (AI + Meaning - The Read Path)
# ============================================================================

"""
A semantic or symbolic pattern discovered across pulses.
Usually AI-generated.
Label: ["FieldResonance"]
"""
type FieldResonance
  @node(labels: ["FieldResonance"]) {
  id: ID! @id @unique
  label: String!
  description: String
}

"""
A justified resonance connection between two pulses.
This is the explainability layer for AI-generated insights.
Label: ["ResonanceLink"]
"""
type ResonanceLink
  @node(labels: ["ResonanceLink"]) {
  id: ID! @id @unique
  confidence: Float!
  evidence: String
  createdAt: DateTime!
  source: FieldPulse!
    @relationship(type: "SOURCE", direction: OUT)
  target: FieldPulse!
    @relationship(type: "TARGET", direction: OUT)
  resonance: FieldResonance!
    @relationship(type: "RESONATES_AS", direction: OUT)
  detectedBy: LifeSensor
    @relationship(type: "DETECTED_BY", direction: OUT)
}
